<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">Node.js Design Patterns | Denis&#x27; Notes</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://antonovtinpa.github.io/notes/docs/category/nodejs-design-patterns"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Node.js Design Patterns | Denis&#x27; Notes"><link data-rh="true" rel="icon" href="/notes/img/brackets.svg"><link data-rh="true" rel="canonical" href="https://antonovtinpa.github.io/notes/docs/category/nodejs-design-patterns"><link data-rh="true" rel="alternate" href="https://antonovtinpa.github.io/notes/docs/category/nodejs-design-patterns" hreflang="en"><link data-rh="true" rel="alternate" href="https://antonovtinpa.github.io/notes/docs/category/nodejs-design-patterns" hreflang="x-default"><link rel="stylesheet" href="/notes/assets/css/styles.e478e7bb.css">
<script src="/notes/assets/js/runtime~main.fdb653f9.js" defer="defer"></script>
<script src="/notes/assets/js/main.5615f779.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/notes/"><b class="navbar__title text--truncate">Denis&#x27; Notes</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/notes/docs/intro">Documents</a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite" aria-pressed="false"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/notes/docs/intro">Denis&#x27; Documents</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/notes/docs/category/system-design-volume-1">System Design Volume 1</a><button aria-label="Expand sidebar category &#x27;System Design Volume 1&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible menu__list-item-collapsible--active"><a class="menu__link menu__link--sublist menu__link--active" aria-current="page" href="/notes/docs/category/nodejs-design-patterns">Node.js Design Patterns</a><button aria-label="Collapse sidebar category &#x27;Node.js Design Patterns&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/notes/docs/nodejs-design-patterns/the-nodejs-platform">Chapter 1. The Node.js Platform</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/notes/docs/nodejs-design-patterns/the-module-system">Chapter 2. The Module System</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/notes/docs/nodejs-design-patterns/callbacks-and-events">Chapter 3. Callbacks and Events</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/notes/docs/nodejs-design-patterns/async-control-flow-with-cb">Chapter 4. Asynchronous Control Flow Patterns with Callbacks</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/notes/docs/nodejs-design-patterns/async-control-flow-with-promises">Chapter 5. Asynchronous Control Flow Patterns with Promises and  Async Await</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/notes/docs/nodejs-design-patterns/coding-with-streams">Chapter 6. Coding with Streams</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/notes/docs/nodejs-design-patterns/creational-design-patterns">Chapter 7. Creational Design Patterns</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/notes/docs/nodejs-design-patterns/structural-design-patterns">Chapter 8. Structural Design Patterns</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/notes/docs/nodejs-design-patterns/behavioral-design-patterns">Chapter 9. Behavioral Design Patterns</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/notes/docs/nodejs-design-patterns/universal-js-for-web">Chapter 10. Universal JavaScript for Web Applications</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/notes/docs/nodejs-design-patterns/advanced-recipes">Chapter 11. Advanced Recipes</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/notes/docs/nodejs-design-patterns/scalability-and-architectural-patterns">Chapter 12. Scalability and Architectural Patterns</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/notes/docs/nodejs-design-patterns/messaging-and-integration-patterns">Chapter 13. Messaging and Integration Patterns</a></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="generatedIndexPage_vN6x"><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/notes/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Node.js Design Patterns</span><meta itemprop="position" content="1"></li></ul></nav><header><h1 class="title_kItE">Node.js Design Patterns</h1></header><article class="margin-top--lg"><section class="row list_eTzJ"><article class="col col--6 margin-bottom--lg"><a class="card padding--lg cardContainer_fWXF" href="/notes/docs/nodejs-design-patterns/the-nodejs-platform"><h2 class="text--truncate cardTitle_rnsV" title="Chapter 1. The Node.js Platform">📄️<!-- --> <!-- -->Chapter 1. The Node.js Platform</h2><p class="text--truncate cardDescription_PWke" title="Така разглеждаме въведение в Node.js, като започваме с кратко изложение на &quot;The Node Way&quot; или оновополагащата философия за използването на Node.js. В това се включва установени конвенции и практики от Node.js общността. Разбира се това са препоръки, а не закони.">Така разглеждаме въведение в Node.js, като започваме с кратко изложение на &quot;The Node Way&quot; или оновополагащата философия за използването на Node.js. В това се включва установени конвенции и практики от Node.js общността. Разбира се това са препоръки, а не закони.</p></a></article><article class="col col--6 margin-bottom--lg"><a class="card padding--lg cardContainer_fWXF" href="/notes/docs/nodejs-design-patterns/the-module-system"><h2 class="text--truncate cardTitle_rnsV" title="Chapter 2. The Module System">📄️<!-- --> <!-- -->Chapter 2. The Module System</h2><p class="text--truncate cardDescription_PWke" title="Така разглеждаме модулните системи в Node.js. Започваме с въпроса за какво са ни модулите и следователно модулните системи? Модулите са полезни по редица причини:">Така разглеждаме модулните системи в Node.js. Започваме с въпроса за какво са ни модулите и следователно модулните системи? Модулите са полезни по редица причини:</p></a></article><article class="col col--6 margin-bottom--lg"><a class="card padding--lg cardContainer_fWXF" href="/notes/docs/nodejs-design-patterns/callbacks-and-events"><h2 class="text--truncate cardTitle_rnsV" title="Chapter 3. Callbacks and Events">📄️<!-- --> <!-- -->Chapter 3. Callbacks and Events</h2><p class="text--truncate cardDescription_PWke" title="Разглеждаме callbacks &amp; events, това са основите, на които изграждаме начина по който се справя с асинхронните операции в JS. Тези две концепции за оснопологащо ако искаме да разберем как работи един async flow в днешно време.">Разглеждаме callbacks &amp; events, това са основите, на които изграждаме начина по който се справя с асинхронните операции в JS. Тези две концепции за оснопологащо ако искаме да разберем как работи един async flow в днешно време.</p></a></article><article class="col col--6 margin-bottom--lg"><a class="card padding--lg cardContainer_fWXF" href="/notes/docs/nodejs-design-patterns/async-control-flow-with-cb"><h2 class="text--truncate cardTitle_rnsV" title="Chapter 4. Asynchronous Control Flow Patterns with Callbacks">📄️<!-- --> <!-- -->Chapter 4. Asynchronous Control Flow Patterns with Callbacks</h2><p class="text--truncate cardDescription_PWke" title="В предишните глави разгледахме основите на асинхронното програмиране в Node.js, разгледахме и callback подхода, но в тази глава се задълбочаваме. Разглеждаме нови проблими свързани с изпълнението на ансинхронен код и някои pattern-и, които биха ни помогнали в определени ситуации, и други, които са по-скоро antipattern-и и трябва да избягваме. Нека да направим лек предговор защо изобщо използваме ансинхронен стил, когато програмираме. Както знаем когато имаме бавна операция, която би блокирала execution thread-a е удачно да се възползваме от възможността да делегираме тази операция и веднъж щом е готова да ни бъде върнат контрола над изпълнението на кода, това става чрез така нареченият callback. Точно това &quot;прехвърляне&quot; на контрола създава объркването, че привидно последователен код всъщност може да бъде изпълнен в непредвидим разбъркан ред, тогава трябва да сме подготвени с установени в индустрията и общността решения, с цел лесно и разбираемо да решаваме различни проблеми.">В предишните глави разгледахме основите на асинхронното програмиране в Node.js, разгледахме и callback подхода, но в тази глава се задълбочаваме. Разглеждаме нови проблими свързани с изпълнението на ансинхронен код и някои pattern-и, които биха ни помогнали в определени ситуации, и други, които са по-скоро antipattern-и и трябва да избягваме. Нека да направим лек предговор защо изобщо използваме ансинхронен стил, когато програмираме. Както знаем когато имаме бавна операция, която би блокирала execution thread-a е удачно да се възползваме от възможността да делегираме тази операция и веднъж щом е готова да ни бъде върнат контрола над изпълнението на кода, това става чрез така нареченият callback. Точно това &quot;прехвърляне&quot; на контрола създава объркването, че привидно последователен код всъщност може да бъде изпълнен в непредвидим разбъркан ред, тогава трябва да сме подготвени с установени в индустрията и общността решения, с цел лесно и разбираемо да решаваме различни проблеми.</p></a></article><article class="col col--6 margin-bottom--lg"><a class="card padding--lg cardContainer_fWXF" href="/notes/docs/nodejs-design-patterns/async-control-flow-with-promises"><h2 class="text--truncate cardTitle_rnsV" title="Chapter 5. Asynchronous Control Flow Patterns with Promises and  Async Await">📄️<!-- --> <!-- -->Chapter 5. Asynchronous Control Flow Patterns with Promises and  Async Await</h2><p class="text--truncate cardDescription_PWke" title="Колкото и полезни да са callback design pattern-ите, истината е, че в днешно време основният способ за справяне с асинхронен код е чрез така наречените Promises. Защо изобщо са се появили promises? Използването на callbacks, дори и след като сме запознати с установени design patterns, е неинтуитивно, лесно води до правене на грешки, особено от неоптни програмисти, callbacks не са специален способ за асинхронно програмиране, а обратно използването им а адаптация от страна на програмистите. Преди появана на promises общността прави различни опити да установи стандарт за справяне с асинхроннни операции, като плод на тези опити е Promises/A+ спецификацията, на която е базирана и имплементацията на JS promises или още познати като ES6 promises. Нека направим сравнение между callback style изпълнението на три поредни таска и promises, като и в давата случая ще напишем примерите по естествен начин, без да прилагаме сложни pattern-и:">Колкото и полезни да са callback design pattern-ите, истината е, че в днешно време основният способ за справяне с асинхронен код е чрез така наречените Promises. Защо изобщо са се появили promises? Използването на callbacks, дори и след като сме запознати с установени design patterns, е неинтуитивно, лесно води до правене на грешки, особено от неоптни програмисти, callbacks не са специален способ за асинхронно програмиране, а обратно използването им а адаптация от страна на програмистите. Преди появана на promises общността прави различни опити да установи стандарт за справяне с асинхроннни операции, като плод на тези опити е Promises/A+ спецификацията, на която е базирана и имплементацията на JS promises или още познати като ES6 promises. Нека направим сравнение между callback style изпълнението на три поредни таска и promises, като и в давата случая ще напишем примерите по естествен начин, без да прилагаме сложни pattern-и:</p></a></article><article class="col col--6 margin-bottom--lg"><a class="card padding--lg cardContainer_fWXF" href="/notes/docs/nodejs-design-patterns/coding-with-streams"><h2 class="text--truncate cardTitle_rnsV" title="Chapter 6. Coding with Streams">📄️<!-- --> <!-- -->Chapter 6. Coding with Streams</h2><p class="text--truncate cardDescription_PWke" title="Разглеждаме Streams в Node.js, те са основополагащи за много операции, които изпълняваме. Най-често те ни служат когато имаме нужда да обработим обем от данни, които надвишават капацитета ни от памет. Например, вместо да изчакаме един файл да бъде изцяло прочетен от файловата система и да го буферираме или казано по друг начин да го запазим в памет, и час след това да извършим операция с него, ние можем да го stream-нем. Тоест можем да прочетем файла на чънкове и да обработим всеки чънк по отделно. Този подход ни помога с няколко основни неща. Подобрява ефикасноста на ползването на памет. Вместо да четем един файл, който може да е мегабайти или гигибайти и да го буферираме, запълвайки нашата памет по този начин, ние ще прочетем файла на много по-малки чънкове. Според зависи от ситуацията в много случаи stream-ването на данни подобрява и бързината, с която се изпълняват определени операции. Трябва да имаме предвид, че това не винаги е така, ако вече имаме данните в паметта е много по-бързо просто да ги предадем. Парадоскалното е че в много случаи ние бихме използвали streams, защото искаме тази обработка да стане по-бавно, ще разгледаме по-късно концепцията за producer, consumer &amp; backpressure. Последното предимство, което ще спомена е адаптивността, която ни дават, подобно на promises, streams имат един интерфейс, което прави chain-ването им много лесно и ни позволява да композираме pipelines, което улеснява обработката им.">Разглеждаме Streams в Node.js, те са основополагащи за много операции, които изпълняваме. Най-често те ни служат когато имаме нужда да обработим обем от данни, които надвишават капацитета ни от памет. Например, вместо да изчакаме един файл да бъде изцяло прочетен от файловата система и да го буферираме или казано по друг начин да го запазим в памет, и час след това да извършим операция с него, ние можем да го stream-нем. Тоест можем да прочетем файла на чънкове и да обработим всеки чънк по отделно. Този подход ни помога с няколко основни неща. Подобрява ефикасноста на ползването на памет. Вместо да четем един файл, който може да е мегабайти или гигибайти и да го буферираме, запълвайки нашата памет по този начин, ние ще прочетем файла на много по-малки чънкове. Според зависи от ситуацията в много случаи stream-ването на данни подобрява и бързината, с която се изпълняват определени операции. Трябва да имаме предвид, че това не винаги е така, ако вече имаме данните в паметта е много по-бързо просто да ги предадем. Парадоскалното е че в много случаи ние бихме използвали streams, защото искаме тази обработка да стане по-бавно, ще разгледаме по-късно концепцията за producer, consumer &amp; backpressure. Последното предимство, което ще спомена е адаптивността, която ни дават, подобно на promises, streams имат един интерфейс, което прави chain-ването им много лесно и ни позволява да композираме pipelines, което улеснява обработката им.</p></a></article><article class="col col--6 margin-bottom--lg"><a class="card padding--lg cardContainer_fWXF" href="/notes/docs/nodejs-design-patterns/creational-design-patterns"><h2 class="text--truncate cardTitle_rnsV" title="Chapter 7. Creational Design Patterns">📄️<!-- --> <!-- -->Chapter 7. Creational Design Patterns</h2><p class="text--truncate cardDescription_PWke" title="Разглеждаме Creational Design Patterns. По самото наименувание можем да разберем, всъщност за какво ни помагат тези pattern-и, а то е за създаване на обекти в различни ситуации. По принцип тези pattern-и са установени от the GoF за други обектно ориентирани програмни езици, но в книгата се разглежда тяхната адаптация в Node.js.">Разглеждаме Creational Design Patterns. По самото наименувание можем да разберем, всъщност за какво ни помагат тези pattern-и, а то е за създаване на обекти в различни ситуации. По принцип тези pattern-и са установени от the GoF за други обектно ориентирани програмни езици, но в книгата се разглежда тяхната адаптация в Node.js.</p></a></article><article class="col col--6 margin-bottom--lg"><a class="card padding--lg cardContainer_fWXF" href="/notes/docs/nodejs-design-patterns/structural-design-patterns"><h2 class="text--truncate cardTitle_rnsV" title="Chapter 8. Structural Design Patterns">📄️<!-- --> <!-- -->Chapter 8. Structural Design Patterns</h2><p class="text--truncate cardDescription_PWke" title="Разглеждаме Structural Design Patterns. Това са решения, които ни помагат да променяме или подобряваме функционалността или интерфейса на един обект, без да променяме същността му. Тези pattern-и са свързани най-често с обгръщане на обектите в определени wrapper-и. Начина на имплементация на различините Structural Design Patterns е много подобен, но значението им е различно.">Разглеждаме Structural Design Patterns. Това са решения, които ни помагат да променяме или подобряваме функционалността или интерфейса на един обект, без да променяме същността му. Тези pattern-и са свързани най-често с обгръщане на обектите в определени wrapper-и. Начина на имплементация на различините Structural Design Patterns е много подобен, но значението им е различно.</p></a></article><article class="col col--6 margin-bottom--lg"><a class="card padding--lg cardContainer_fWXF" href="/notes/docs/nodejs-design-patterns/behavioral-design-patterns"><h2 class="text--truncate cardTitle_rnsV" title="Chapter 9. Behavioral Design Patterns">📄️<!-- --> <!-- -->Chapter 9. Behavioral Design Patterns</h2><p class="text--truncate cardDescription_PWke" title="Разглеждаме Behavioral Design Patterns, които се фокусират над комуникацията и интеракцията между обектите в нашата програма. Те ни дават подходи за създаване на по-адаптивна и по-гъвкава апликация, където отедлните модули могат да се преизползват по интуитивен начин. Пример за Behavioral Design Pattern е Observer Pattern-a, който вече разгледахме в предишни глави.">Разглеждаме Behavioral Design Patterns, които се фокусират над комуникацията и интеракцията между обектите в нашата програма. Те ни дават подходи за създаване на по-адаптивна и по-гъвкава апликация, където отедлните модули могат да се преизползват по интуитивен начин. Пример за Behavioral Design Pattern е Observer Pattern-a, който вече разгледахме в предишни глави.</p></a></article><article class="col col--6 margin-bottom--lg"><a class="card padding--lg cardContainer_fWXF" href="/notes/docs/nodejs-design-patterns/universal-js-for-web"><h2 class="text--truncate cardTitle_rnsV" title="Chapter 10. Universal JavaScript for Web Applications">📄️<!-- --> <!-- -->Chapter 10. Universal JavaScript for Web Applications</h2><p class="text--truncate cardDescription_PWke" title="азглеждаме фундаментите за универсален JS за уеб приложения или с други думи как да изградим една цялостна апликация, както фронтенд, така и бакенд изцяло използвайки JS. Това е практика, която в днешно време не е нищо странно, вече имаме frameworks като Next.js, които правят точно това - пресичат границата между клиента и сървъра.">азглеждаме фундаментите за универсален JS за уеб приложения или с други думи как да изградим една цялостна апликация, както фронтенд, така и бакенд изцяло използвайки JS. Това е практика, която в днешно време не е нищо странно, вече имаме frameworks като Next.js, които правят точно това - пресичат границата между клиента и сървъра.</p></a></article><article class="col col--6 margin-bottom--lg"><a class="card padding--lg cardContainer_fWXF" href="/notes/docs/nodejs-design-patterns/advanced-recipes"><h2 class="text--truncate cardTitle_rnsV" title="Chapter 11. Advanced Recipes">📄️<!-- --> <!-- -->Chapter 11. Advanced Recipes</h2><p class="text--truncate cardDescription_PWke" title="Към този момент сме разгледали доста design pattern-и и добри практики. В тази глава прилагаме голяма част от наученото към този момент в практически примери. Имаме няколко установени решения на често срещани проблеми в истинския живот. Разглеждаме как да се справим с асинхронни компоненти, как да оптимизираме асинхронни операции чрез batching &amp; caching, разглеждаме как се прекъсват асънхронни операции и как да изпълнявата CPU heavy операции по най-ефективният начин.">Към този момент сме разгледали доста design pattern-и и добри практики. В тази глава прилагаме голяма част от наученото към този момент в практически примери. Имаме няколко установени решения на често срещани проблеми в истинския живот. Разглеждаме как да се справим с асинхронни компоненти, как да оптимизираме асинхронни операции чрез batching &amp; caching, разглеждаме как се прекъсват асънхронни операции и как да изпълнявата CPU heavy операции по най-ефективният начин.</p></a></article><article class="col col--6 margin-bottom--lg"><a class="card padding--lg cardContainer_fWXF" href="/notes/docs/nodejs-design-patterns/scalability-and-architectural-patterns"><h2 class="text--truncate cardTitle_rnsV" title="Chapter 12. Scalability and Architectural Patterns">📄️<!-- --> <!-- -->Chapter 12. Scalability and Architectural Patterns</h2><p class="text--truncate cardDescription_PWke" title="Разглеждаме подходи за скалиране на една Node.js апликация. По принцип има два основни начина да скалираме каквото и да е - вертикално и хоризонтално. Вертикалното скалиране се състои в това да се подобрят способносите на определен сървър чрез хардуерни модификации, но поради факта, че JS е single-threaded език, за да се възползваме от повече CPU power/cores ние всъщност трябва да отворим нови процеси, което се равнява на хоризонтално скалиране. В тази глава, обаче, разглеждаме техники за скалиране, които са малко конкретни. Имаме три измерения на скалиране, които са описани в &quot;scale cube&quot; модела:">Разглеждаме подходи за скалиране на една Node.js апликация. По принцип има два основни начина да скалираме каквото и да е - вертикално и хоризонтално. Вертикалното скалиране се състои в това да се подобрят способносите на определен сървър чрез хардуерни модификации, но поради факта, че JS е single-threaded език, за да се възползваме от повече CPU power/cores ние всъщност трябва да отворим нови процеси, което се равнява на хоризонтално скалиране. В тази глава, обаче, разглеждаме техники за скалиране, които са малко конкретни. Имаме три измерения на скалиране, които са описани в &quot;scale cube&quot; модела:</p></a></article><article class="col col--6 margin-bottom--lg"><a class="card padding--lg cardContainer_fWXF" href="/notes/docs/nodejs-design-patterns/messaging-and-integration-patterns"><h2 class="text--truncate cardTitle_rnsV" title="Chapter 13. Messaging and Integration Patterns">📄️<!-- --> <!-- -->Chapter 13. Messaging and Integration Patterns</h2><p class="text--truncate cardDescription_PWke" title="В тази глава продължаваме да разглеждаме концeпции, които са тясно свързани със скалируемост. В миналта глава споменахме Message Queues, като способ за комуникация на отделни services, когато прилагаме скалиране по Y Axis. В тази галва разгръщаме общата идея за Messaging, разглеждаме фунадамента и различни pattern-и, които можем да използваме в нашата интеграция.">В тази глава продължаваме да разглеждаме концeпции, които са тясно свързани със скалируемост. В миналта глава споменахме Message Queues, като способ за комуникация на отделни services, когато прилагаме скалиране по Y Axis. В тази галва разгръщаме общата идея за Messaging, разглеждаме фунадамента и различни pattern-и, които можем да използваме в нашата интеграция.</p></a></article></section></article><footer class="margin-top--lg"><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/notes/docs/system-design-vol-1/design-google-drive"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Chapter 15. Design Google Drive</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/notes/docs/nodejs-design-patterns/the-nodejs-platform"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Chapter 1. The Node.js Platform</div></a></nav></footer></div></div></main></div></div></div></div>
</body>
</html>