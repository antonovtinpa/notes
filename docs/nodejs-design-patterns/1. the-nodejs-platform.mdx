---
title: Chapter 1. The Node.js Platform
sidebar_position: 1
---

Така разглеждаме въведение в Node.js, като започваме с кратко изложение на "The Node Way" или оновополагащата философия за използването на Node.js. В това се включва установени конвенции и практики от Node.js общността. Разбира се това са препоръки, а не закони.

Започваме с идеята за малкото ядро. Самата Node.js платформа има за цел да е възможно най-минималистична, тоест да предлага основните задължителни функционалностти на потребителите и, това я прави много по-лесна за поддържане. В същото време тази практика предоставя възможността да развиват екосистемата на Node.js по гъвкав и креативен начин като създават собтвени модули, които да решават специфични проблеми. Тези модули могат да се използват и преизползват по лесен начин, чрез packet manager-и като npm, pnpm, yarn и т.н, това е олицетворението на DRY принципа. Тук продължаваме с приетите практики относно модулите (пакетите), които се създават. По прицип е предпоръчително те да са малки, семпли и да решават точно определен проблем (тук се хинтва принципа за single responsibility), като модулте се правят по-скоро за използване, от колкот за надграждане и разширяване. Това намалява гъвкавостта на пакета, но за сметка на това се специализара в точно определен use case, прави времето за изработка минимално и улеснява поддръжката. Посленото нещо, което е предпоръчително за изпработката на модули е това те да са възможно най-абстрактни, създаваме модула с цялата вътрешна имплементация, но отваряме семпъл лесен за използване API, с добра документация. Така намаляваме шанса за неправилно използване на пакета. Завършваме с KISS принципа, предпочитаме имплементацията да е лесна за разбиране и поддръжка, да работи правилно и да решава проблем, но не е задължително да е перфектна, перфекционизма води до overengineering.

Едно от основните неща, които правим на сървъра е I/O операции или така наречените input/output операции, това включва, четене от диск или от мрежата, записване на данни и много други операции. Специфичното за тях е, че повечето да много бавни, те могат да отнемат от милисекунди до цели минути. По прицнип синхронното изпълняване на такива операции е един от големите проблеми, с които се сбълкваме понеже това означата, че thread-a ни бива блокиран. Традиционно ние се справяме с този проблем, чрез използването на множество thread-ове, но както знаем JavaScript e single-threaded език. За това трябва да разгледаме как Node.js се справя с блокиращите I/O операции. Първата концепция, която трябва да разгледаме, е busy polling (busy-waiting). При този подход ние изпращаме заявка към даден ресурс (например четене на файл) и веднага получаваме отговор. Възможно е отговорът да бъде, че данните все още не са готови. В този случай ние продължаваме да "питаме" ресурса дали вече има резултат, докато той не бъде готов. По този начин не блокираме напълно thread-а, но постоянно хабим ресурса на процесора в проверки, което го прави изключително неефективен подход. За щастие, Node.js използва друг механизъм за справяне с проблема на блокиращите операции, наречен Event Demultiplexing. Нека първо изясним какво всъщност означава "demultiplexing". Идеята идва от телекомуникациите, където:

- **Multiplexing** е процесът на комбиниране на потоци от данни в един общ канал за по-ефективно пренасяне.
- **Demultiplexing** е обратното – разделянето на този общ канал обратно на оригиналните му отделни потоци.

Node.js адаптира тази идея по следния начин - Когато Node.js трябва да изчака данни от различни ресурси, тя регистрира тези ресурси в специален компонент на операционната система, наречен Event Demultiplexer. Този компонент „изчаква“, без да изразходва излишно ресурса на процесора, докато поне един от регистрираните ресурси стане готов (например пристигат данни от http заявка или приключва файлова операция). В момента, в който това се случи, операционната система връща на Node.js информация кой точно ресурс е готов под формата на евент (това реално е процесът на **demultiplexing**), този евент се запазва в така нареченото Event Queue, което е част от Node.js. Всеки евент има асоцииран към себе си handler, това е важно, защото за да излезе от опашката евента трябва да бъде обработен, а това става, чрез този handler. За да управлява този процес, Node.js използва Event Loop механизъм, който постоянно проверява Event Queue-то и изпълнява съответните handler-и за евентите в опашката. По този начин Node.js може да обработва множество асинхронни операции без да блокира изпълнението на основния thread. Това е така нареченият Reactor Pattern.

С цел използването на Node.js в различни среди като Linux, macOS и Windows, които имат различни начини за управление на ресурси и извършване на I/O операции, към Node.js върви и така нареченият I/O engine – libuv. Това е cross-platform библиотека, която имплементира Reactor Pattern и използва Worker Pool за делегиране на по-тежки задачи като файлови операции и криптография, като сама се справя със спецификите на различните операционни системи.

Нужни са ни още няколко компонента за да положим фундамента на Node.js. Това е JavaScript engine-a, който изпълнява програмите ни, това V8 на Google. Трябват ни различни binding-и, които ни дават достъп до lower level функционалности. Последно, но не на последно място ни трябва фундаментална JS библиотека, чрез която да можем да извършваме базови операции.

Накрая ще сравним JS в браузъра и в Node.js. Първо в Node.js, нямаме DOM дърво, нямаме document обект нито window обект, за сметка на това имаме достъп до OS системи и операции. Когато пишем JS на сървъра не трябва да имаме притеснения за това в каква среда ще се изпълнява кода, по принцип имам представа за това каква ще ни е средата, докато на клиента той се изпълнява на различни браузъри и устройства, което го прави малко по-непредвидим. Има и други специфични разлики като модулните системи (CommonJS е default-a на Node.js, въпреки, че се възползва от синтаксиса на ES6 модулите), но те са по-скоро строго domain based.
