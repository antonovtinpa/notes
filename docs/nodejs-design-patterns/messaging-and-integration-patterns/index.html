<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-nodejs-design-patterns/messaging-and-integration-patterns" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">Chapter 13. Messaging and Integration Patterns | Denis&#x27; Notes</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://antonovtinpa.github.io/notes/docs/nodejs-design-patterns/messaging-and-integration-patterns"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Chapter 13. Messaging and Integration Patterns | Denis&#x27; Notes"><meta data-rh="true" name="description" content="В тази глава продължаваме да разглеждаме концeпции, които са тясно свързани със скалируемост. В миналта глава споменахме Message Queues, като способ за комуникация на отделни services, когато прилагаме скалиране по Y Axis. В тази галва разгръщаме общата идея за Messaging, разглеждаме фунадамента и различни pattern-и, които можем да използваме в нашата интеграция."><meta data-rh="true" property="og:description" content="В тази глава продължаваме да разглеждаме концeпции, които са тясно свързани със скалируемост. В миналта глава споменахме Message Queues, като способ за комуникация на отделни services, когато прилагаме скалиране по Y Axis. В тази галва разгръщаме общата идея за Messaging, разглеждаме фунадамента и различни pattern-и, които можем да използваме в нашата интеграция."><link data-rh="true" rel="icon" href="/notes/img/brackets.svg"><link data-rh="true" rel="canonical" href="https://antonovtinpa.github.io/notes/docs/nodejs-design-patterns/messaging-and-integration-patterns"><link data-rh="true" rel="alternate" href="https://antonovtinpa.github.io/notes/docs/nodejs-design-patterns/messaging-and-integration-patterns" hreflang="en"><link data-rh="true" rel="alternate" href="https://antonovtinpa.github.io/notes/docs/nodejs-design-patterns/messaging-and-integration-patterns" hreflang="x-default"><link rel="stylesheet" href="/notes/assets/css/styles.e478e7bb.css">
<script src="/notes/assets/js/runtime~main.fdb653f9.js" defer="defer"></script>
<script src="/notes/assets/js/main.5615f779.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/notes/"><b class="navbar__title text--truncate">Denis&#x27; Notes</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/notes/docs/intro">Documents</a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite" aria-pressed="false"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/notes/docs/intro">Denis&#x27; Documents</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/notes/docs/category/system-design-volume-1">System Design Volume 1</a><button aria-label="Expand sidebar category &#x27;System Design Volume 1&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/notes/docs/category/nodejs-design-patterns">Node.js Design Patterns</a><button aria-label="Collapse sidebar category &#x27;Node.js Design Patterns&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/notes/docs/nodejs-design-patterns/the-nodejs-platform">Chapter 1. The Node.js Platform</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/notes/docs/nodejs-design-patterns/the-module-system">Chapter 2. The Module System</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/notes/docs/nodejs-design-patterns/callbacks-and-events">Chapter 3. Callbacks and Events</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/notes/docs/nodejs-design-patterns/async-control-flow-with-cb">Chapter 4. Asynchronous Control Flow Patterns with Callbacks</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/notes/docs/nodejs-design-patterns/async-control-flow-with-promises">Chapter 5. Asynchronous Control Flow Patterns with Promises and  Async Await</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/notes/docs/nodejs-design-patterns/coding-with-streams">Chapter 6. Coding with Streams</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/notes/docs/nodejs-design-patterns/creational-design-patterns">Chapter 7. Creational Design Patterns</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/notes/docs/nodejs-design-patterns/structural-design-patterns">Chapter 8. Structural Design Patterns</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/notes/docs/nodejs-design-patterns/behavioral-design-patterns">Chapter 9. Behavioral Design Patterns</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/notes/docs/nodejs-design-patterns/universal-js-for-web">Chapter 10. Universal JavaScript for Web Applications</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/notes/docs/nodejs-design-patterns/advanced-recipes">Chapter 11. Advanced Recipes</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/notes/docs/nodejs-design-patterns/scalability-and-architectural-patterns">Chapter 12. Scalability and Architectural Patterns</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/notes/docs/nodejs-design-patterns/messaging-and-integration-patterns">Chapter 13. Messaging and Integration Patterns</a></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/notes/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/notes/docs/category/nodejs-design-patterns"><span itemprop="name">Node.js Design Patterns</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Chapter 13. Messaging and Integration Patterns</span><meta itemprop="position" content="2"></li></ul></nav><div class="theme-doc-markdown markdown"><header><h1>Chapter 13. Messaging and Integration Patterns</h1></header><p>В тази глава продължаваме да разглеждаме концeпции, които са тясно свързани със скалируемост. В миналта глава споменахме Message Queues, като способ за комуникация на отделни services, когато прилагаме скалиране по Y Axis. В тази галва разгръщаме общата идея за Messaging, разглеждаме фунадамента и различни pattern-и, които можем да използваме в нашата интеграция.</p>
<p>Нека започнем с няколко фундаментални идеи. Message системите общо казано могат да се разделят по няколко критерии. Първият критерии е посоката на комуникация, тя може да е еднопосочна или още позната като fire-and-forget, като например определен producer създава task-ове и consumers, които ги поемат и изпълняват, тя може да е също request/reply или двупосочна, която е малко по-сложна за имплементиране и ще разгледаме по-късно. Вторият критерии е целта на съобщението, като тук имаме три вида цели command, подава се точно оперделена команда от producer и се изпълнява от consumer, event, подава се определено нещо, което се е случило и consumer-ите сами решават как да реагират &amp; document, това е съобщение, което предава определени данни като payload. Имаме и разделение на база timing, имаме синхронни и асинхронни message systems, като в Node.js света най-вече разчитаме на асинхронност, с цел да постигнем самостоятелност, бързина и издръжливост. Последният критерии, който имаме е на база доставяне, то може да е peer-to-peer или с други думи директно от един node към друг или Broker-Based, в който имаме брокер, който служи за посредник и в много случаи ни помага с други неща като routing, persistence и други, които ще разгледаме по-късно.</p>
<p>Един от основните pattern-и, когато става въпрос за messaging е Pub/Sub (Publisher/Subscriber). Това едно от много вариации на Observer pattern-a. Идеята е че имам publishers, които подават съобщения към даден topic или канал, а от другата страна имаме subscribers, които са абониране за споменатия topic/channel, получават копия на публикуваните събщенията и ги консумират. Този подход ни дава гъвкавост, поради самостоятелността на елементите. Самият Pub/Sub на практика има много и различни имплементации, общо казано голямата разлика е дали имплементацияте е peer-to-peer или broker-based. При peer-to-peer една имплементация може да е по-проста и съответно по-лимитирана, например да се отвори една web socket връзка, използвайки библиотеки като <code>socket.io</code>, където всеки вързан клиент да може да публикува съобщения към определен канал и съответно на база тези пуликации да получава новите съобщения. Друг по-софистициран вариант би бил използването на <code>ZeroMQ</code>, което като технология вече приспада към message queues, за разлика <code>socket.io</code>, което е high level абстракция на протокол за комуникация. <code>ZeroMQ</code> всъщност се използва за играждане на много други видове архитектури, но ни позволява и да имплементираме и Pub/Sub, чрез специални сокети PUB &amp; SUB, като publisher-a се връзва към определен адрес за да публикува и всички абонати, които съще се свържат към къщия адрес ще получават тези публикации. Съответно лимитациите на тези имплементации са, че съобщенията не се пазят и абонати, които не са били на линия по време на публикацията никога няма да я получат. За да решим този проблем можем да използваме Broker-based имплементация, чрез технологии като RabbitMQ. RabbitMQ имплементира така нареченият Advanced Message Queueing Protocol (AMQP), който разделя messaging system-aта на няколко части, publisher, broker, в който има exchange, bindings &amp; queues и consumers. В нашия случай брокерът е това, което би могло да реши проблема. Publisher-ът изпраща съобщения към exchange, който ги route-ва към една или повече опашки. Ако опашките са конфигурирани като durable, а съобщенията - като persistent, те ще се запазят дори при рестарт на системата. Така гарантираме, че нито едно съобщение няма да бъде изгубено, дори ако абонатите не са били свързани в момента на публикуване. По принцип може би факта, че трябва да конфигурираме това държание подсказва, че това не е точно предназначението на message queues като RabbitMQ. По default в повечето случаи използваме message queues за fire-and-forget тип системи, в нашият случай чрез таки конфигурация по-скоро мимикираме event stream-овете или още познати като event log-ове. Такива технологии са Redis Streams &amp; Kafka при тях системата е малко по-сложна. Например при Kafka пак имаме producers &amp; consumers, но съобщенията са разделени на partitions, всеки от който има topic, един topic може да се консумира от множество consumers, като консумацията става не на база кой е следващото съобщение в опашката, както е при message queue-тата, а на база кое беше последното съобщение, което аз съм прочел, понеже съобщенията са персистентни в лог-а. С други думи консумирането става на база персонален офсет на консуматора. Съответно ако искаме едно съобщение да се приема само от един косуматор можем да изградим така наречените consumer groups. Както message queues, така и event/message streams/logs са broker-based messaging systems, но приложенията са различни и съответно трябва да съобразим нашите нужди с целта на технологията. Като обощение можем да кажем следното: Peer-to-peer системите са по-low level, по-сложни са за интеграция за големи приложения, в повечето случаи сами трябва да превидим механизми за загубени съобщения, за сметка на това са много по-бързи и по-издръжливи (не като цяло, а в точно определен аспект) поради факта, че всяка връзка е директна и самостоятелна. Broker-based системите от своя страна са по-бавни, правят ни vendor зависими, но за сметка на това са много по-гъвкави, по-издружливи, поради множеството механизми, които ни предлагат, много по-лесно скалируеми.</p>
<p>Една от най-често срещаните нужди, които message системите задоволяват е прехвърлянето на задачи, тоест комуникацията между отделни компонент с цел изпълнение на една сложна задача или по друг начин казано изграждането на work pipelines. Пример за такъв pipeline и ползите от използването на message queues би бил транскодирането на едно видео. Определено видео трябва да бъде обработено така че да поддържа различни резолюции (240, 360, 420, 680, 720, 1080), за тази цел, ние можем да имаме следнят flow. Клиент праща видео - чрез message queue URL-a на всяко видео се изпраща на blocking service, който разделя видеото на чънкове, които са по-малки по размер. След това за всеки чънк се изпраща отделно съобщение, като към това съобщение имаме множество консуматори или множество consumer groups, като всеки консуматор ще е service, който има за цел да encode-не чънк-а от един bitrate (оригиналния) към друг (240, 360, 420...), след това всеки от тези services има за задача да изпрати съобщение, че чънка е готов на друг service, който ще ги съедини и качи в storage. Това е така нареченият fan out/fan in модел, можем да забележим, че една задача се разделя на други по-малки, които могат да се изпълнят паралелно и след това разултати се съединяват. Това е много ефективна техника и е широкоизползвана. Освен очевидното препращане на съобщенията messaging system-ите правят тази имплементация балансирана поради load balancing механизмите, които прилагат и също така я правят издръжлива и fault resistant, поради acknowledgment механизма, който прилагат. По default повечето messaging systems прилагат At-Least-Once Delivery, което означава, че едно съобщение ще се достави поне веднъж, но ако консуматора дропне то тогава то може да бъде retry-нато и съответно неговият ефект да се дубликира. По принцип acknowledgment-а е задължение на консуматора като различните системи предоставят възможност за това по различен начин. Има и системи, които прилагат At-Most-Once Delivery и Exactly-Once Delivery, като AMOD би се приложило при системи, които са Loss tolerance, а EOD е идеалът за една messaging system-a, но е много трудно постижим.</p>
<p>Последният pattern, който ще разгледаме е двупосочният messaging или request/reply pattern-a. В повечето случаи ние имаме някакъв Pipeline или еднопосочна комуникация, но в случаите, в които искаме изградим ефективен flow, в който да получим отговор на определено съобщение трябва да приложим две основно идеи. Първата е Correlation Identifier, с прости думи това е ID за определена задача. Да кажем един service подава задача за някакво изчисление чрез определен topic на втори service и продължава работата си, веднъж щом вторият service e готов той би пратил съобщение към различен topic за да обяви отговорът от изчислението, с други думи имаме два topic-a - <code>calculation &amp; result</code>. При <code>&quot;calculation&quot;</code> <code>service A</code> e producer, a <code>service B</code> consumer, при topic <code>&quot;result&quot;</code> обратното. Идеята на Correlation Identifier-а е да се установи корелацията между заявката за калкулиране и резултата. Другата идея е Return Address-а общо взето return address-a е <code>result</code> topic-a, въпросът е че не винаги искаме той е статичен и в повечето случаи искаме producer-a да опердели къде ще се прати резултата. Тези две концепции са фундаментални и се използват от повечето messaging systems под различни форми.</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/notes/docs/nodejs-design-patterns/scalability-and-architectural-patterns"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Chapter 12. Scalability and Architectural Patterns</div></a></nav></div></div></div></div></main></div></div></div></div>
</body>
</html>