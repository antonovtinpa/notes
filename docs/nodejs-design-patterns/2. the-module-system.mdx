---
title: Chapter 2. The Module System
sidebar_position: 2
---

Така разглеждаме модулните системи в Node.js. Започваме с въпроса за какво са ни модулите и следователно модулните системи? Модулите са полезни по редица причини:
- Организация на кода - Когато разделим апликацията си на многожество логично организирани файлове ни в пъти по-лесно да се ориентираме и да поддържаме код базата.
- Преизползване на логиката - Когато решим един проблем в определена част от апликацията ни бихме искали да имаме възможност да решим същия или подобен проблем по безболезнен начин и на друго място.
- Екапцулация или прикриване на имплементационни детайли - В първа глава го осъдихме на кратко, но ние като програмисти искаме да прикрием възможно най-много имплементационни детайли и да отворим публичен достъп само за определени позволени дейстия и данни. Това е с цел да гарантираме до колкото можем правилното и лесно използване на модула ни.
От своя страна модулните системи ни помагат по следният начин:
- Управление на dependency-та (т.е. модулите и пакетите).
- Ще разгледаме, че ни помагат и с performance-a на апликацията, като веднъж използвани модули се кешират и по този начин не преизпълняваме код при всеки импорт.

Кратка история на модулните системи в JS ecosystem-ата. Доста дълго време изобщо не е съществувала вградена модулна система, просто не е имало нужда. В браузъра програмистите са можели да използват различни файлове, чисто и просто, чрез използване на множество `<script><script />` тагове. В днешно време това е непонятна практика, защото знаем какви са последствията от namespace pollution-a. До този извод стига и community-то, като се появяват Async Module Definition (AMD), това е нов начин за зараждане на модули по асинхронен начин директно в браузъра. Голяма част от общността приема AMD, но все още няма наложен стандарт, за това се появява и Universal Module Definition (UMD), който скъсява дистанцията между различните конвенции. Enter CommonJS, това е първият опит за налагане на стандарт, именно от екипа на Node.js. CJS предоставя лесен синтаксис за export-ване и импортване на модули, чрез `module.exports` и `require()`. Най-новата и завършена модулна система в JS екосистемата е ECMAScript 6 Modules (ESM), тя надгражда над CJS и улеснява още повече синтаксиса, чрез `import` и `export`.

Правим няколко стъпки назад за видим всъщност къде започва всичко. Първият стандартизиран модул е така нареченият Revealing Module Pattern, преди да имаме екстри като `const`, `let` и дори `block scope`, ние сме имали function scope и всичко, което е трябвало да прикрием се е намирало там. За да поясня Revealing Module Pattern-а се състои в това да изградим function-scoped state & behavior, който да не е публично достъпен, за сметка на това да върнем обект, който да представлява публично достъпен API, който да контролира или да взимодейства с нашият state & behavior. Този пдоход използва идеята за closure-и и се имплементира чрез IIFE-та.

Пропускаме AMD & UMD, може да се върнем по-нататък, когато прочета повече.

Стигаме до CJS модулната система наложена от екипа на Node.js. Тя предоставя лесно синхронно импортиране на модули чрез `require()`, кеширащи механизми за по-добър performance и интуитивен и лесен начин за експорт чрез `exports` & `module.exports`. Нека започнем с `require()`, използва се по следният начин `const logger = require("./logger.js")`, функцията ще потърси модула на база **resolution algorithm**, когато намери файла ще го wrap-не в собстен function scope, ще изпълни функцията, ще върне `module.exports` и ще кешира резултата. Има едно важно нещо, което трябва да знаем, когато експортираме променливи, класове и функции от един CJS модул. В самият модул ние имаме достъп до `exports` & `module.exports`, по дефаулт и двете променливи сочат към един и същи обект, тоест ние можем да asign-ваме стойности към експорт обекта и по следният начин `exports.foo = () => "bar"`, но това е при условие, че не сме override-нали exports, по следният начин `exports = {}`, в крайна сметка експорт обекта ще е този, който е назначен на `module.exports`, просто ни се предоставя и кратка версия, която можем да мутираме.

Споменахме resolution algorithm, малко по-нагоре. Това е алгоритъма, който се изпълнява при require-ването на модул. Има няколко сценарии, които трябва да разгледаме.
- Когато модула започва с ./ или /, тогава ние ще търсим локален файл според path-a, който сме дали.
- В противен случай първо ще търсим някой от вградените core модули, ако не намерим модула там ще търсим в `node_modules` папката, а ако има повече от една ще потърсим всяка папка от сегашната директория нагоре.
Когато намерим модула търсим entry point-a, той ще е `moduleName.js`, `moduleName/index.js` или ще е специфициран в `package.json-a`.

Един голям проблем при CJS, който трябва да споменем е справянето с така наречените Circular Dependencies, например модул A import-ва модул В, но от своя страна модул В също импортва модул А, в такава ситуация единият модул най-вероятно ще има непълна версия на другият, това се случва заради синхронната същност на CJS. Този проблем се решава от ESM в бъдещето.

ESM въвежда нов синтаксис и асинхронно зареждане на модулите. Вече named export-итете могат да се обявява с `export const NAME = "DENIS"` или `export function say(){}`, като можем да имаме и дефаултен експорт, като `module.exports`, който просто изглеждата така `export default {}`. А начина на импортване се променя по следният начин `import {NAME} from "module"`, `import module from "module"`, `import * as module from "module"`. Новият начин за импортване е нареченият static import, което означава, че първото нещо, което трябва да направим е да обявим всички импорти в началото, тоест губим правото да импортваме динамично или в conditional, поне по този начин. За динамични импорти бихме използвали `import()` функцията. Общо взето е това, последното нещо, което искаме да обясним е как всъщност ESM решава проблема със Circular Dependencies. Знаем, че CJS импортва модули синхронно като за всеки нов модул импортва неговите dependency-та, DFS style. От своя страна ESM, само събира dependency-тата, но не ги изпълнява, а всъщност изгражда directed graph, като за всяка връзка създава Line Bindings, тоест имаме референции между модулите. Веднъж щом сме създали графата изпълняваме кода в подобаващ ред.