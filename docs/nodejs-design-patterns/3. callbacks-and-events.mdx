---
title: Chapter 3. Callbacks and Events
sidebar_position: 3
---

Разглеждаме callbacks & events, това са основите, на които изграждаме начина по който се справя с асинхронните операции в JS. Тези две концепции за оснопологащо ако искаме да разберем как работи един async flow в днешно време.

Започваме с callbacks. В много от програмните езици за изпълнението на блокиращи операции по неблокиращ начин използваме така наречените thread-ове, теост за да изпълним блокираща операция бихме създали thread, който да се справи с нея, докато main thread-a остава свободен. В JS нямаме концепцията за създаване на thread-ове, JS е single-threaded език и следователно се справя с асинхронните операции по различен начин, а именно чрез Event Loop-a, в първа глава когато стана дума за Reactor Pattern-a споменахме и Event Queue-то, където се пушват готовите евенти, към които е закачен handler. Този handler, всъщност е така нареченият callback. Callback-a е нищо повече от фунцкия с точно определен signature, която се подава като аргумент при извикването на друга функция, която ни предоставя някаква асинхронна операция. Такава е конвенцията в JS екосистемата, а реално ние можем така да подаваме функции в JS, защото те са така наречените first class citizens, тоест ние можем да ги assing-ваме към променливи и съответно да ги подаваме като аргументи. Целта на този callback е да бъде извикан щом операцията е приключила, по конвенция също този callback приема като първи аргумент error, който ще е ерор обект или null/undefined. Пример:
```js
fs.readFile('./file', (error, data) => {
  if (err) {
	  console.log(error.message);
  } else {
	  console.log(data);
  }
});
```

Всъщност за да изградим някакъв по-сложен flow ни е нужна и още една концепция, която се нарича Continuation-Passing Style. Общо взето когато прилагаме този подход изместваме традиционното връщане на резултат с извикване на callback. Пример:
```js
const traditional = (a, b) => a + b
traditional(1, 3) // 4

const passing = (a, b, cb) => cb(a + b)
passing(1, 3, (a, b) => console.log(`${Result}: ${a + b}`)) // Result: 4
```
Тук нещото, с което трябва да внимаваме е как установяваме flow-a, в горните примери той е синхронен, тоест callback-a се извиква веднага, но както вече казахме, най-често използваме callback подхода за асинхронни операции и когато имаме случаи, в които кодът ни може да се изпълни синхронно или асинхронно според зависи от ситуацията това може да доведе до наочквано подедение и проблеми, за това е най-добре да се придържаме към един подход, ако има нужда от това да преобразуваме едно синхронно извикване към асинхронно то тогава можем да използваме `process.nextTick` или `setImmediate`, като това означава, че callback-a ще бъде добавен в micro task queue-то, което е като even queue-то, но има по-голям приоритет, тоест при следващият цикъл на event loop-a евентите в micro task queue-то ще се handle-нат първо.

Последна бележка, споменахме вече, че при грешка можем да подадем ерор обекта на callback-a като първи аргумент. Това е задължителна практика ако искаме да си осигурим добър error handling.

Подаването на callback е сравнитлно прост подход, но бързо стигаме до заключенито, че не е толкова просто когато трябва да следим много на брой операции и когато искаме да реагираме по различни начини. Формалната терминология e, че говорим за Observer Pattern-a, той се състои от два компонента: EventEmitter & Listeners. EventEmitter-а е субекта на наблюдение, той представлява JS обект, който предоставя методи за добавяне на наблюдетели или listeners, които да следят за евенти и съответно метод за emit-ване на евент, който да тригърне тези listener-и. Пример:
```js
const emitter = new EventEmitter();

emitter
  .on("myEvent", () => console.log("Event time!"))
  .on("error", (error) => console.log(error.message));

emitter.emit("myEvent");
emitter.emit("error", new Error("Custom error!"));
```
Тук също присъства проблема за синхронно срещу асинхронно изпълняване на операции. Трябва да се има предвид, че е напълно възможно да изпълним синхронна операция, която емитва евент преди да сме закачили listener-a. Проблеми можем да създадем и чрез така наречените memory leaks, това се случва когато не освобождаваме listener-ите след като са изпълнили задачата си, това правим чрез `removeListener` метода или ако искаме да закачим еднократен listener, го закачаме с `once` вместо `on`.

Нещо интересно за EventEmitter е, че всъщност той е клас, който ние можем да extend-нем, не само можем, а разчитаме на това, че може да се extend-ва, понеже много от вградените модули в Node.js са изградени върху него.

Като заключение можем да обобщим кога да използваме callbacks & events. Те всъщност са много близки по значение и използване и в много случаи за взаимозаменяеми, но основното правило е, че можем да използваме прост callback подход когато имаме еднократна реакция на определена операция, а EventEmitter, когато имаме постоянни ъпдейти и когато искам да рагираме по множество начини. В някои случай дори можем да обединим подходите, например когато искаме да реагираме еднократно при изпълнение на определена операция, но можем да получим и ъпдейт в бъдещето. 