---
title: Chapter 10. Universal JavaScript for Web Applications
sidebar_position: 10
---

азглеждаме фундаментите за универсален JS за уеб приложения или с други думи как да изградим една цялостна апликация, както фронтенд, така и бакенд изцяло използвайки JS. Това е практика, която в днешно време не е нищо странно, вече имаме frameworks като Next.js, които правят точно това - пресичат границата между клиента и сървъра.

За да изградим такава универсална апликация, първо трябва да се сблъскаме с модулните системи. Както знаем Node.js използва по default CommonJS, от своя страна браузърите много дълго време не са имали модулна система, в днешно време всички модерни браузъри използват ESM, но не можем да разчитаме, че всички потребители имат модерни браузири, които са ъпдейтнати. Също така в Node.js модулите се зареждат от файловата система, докато в браузъра това се случва чрез http заявки. Tози проблеми се решава от така наречените Module Bundlers, те бъндълват или опаковат всички модули, които са нужни на приложението в няколко оптимизирани файла, това се случва чрез така нареченият packing. Packing-ът се случва, след като сме събрали всички dependency-та и сме ги организирали като graph, използвайки тази диаграма bundler-a групира модулите и създава IIFE, която има module map, където всеки модул е проперти и съответно предоставя къстъм импорт функция, на която може да се подаде модула и съответно да се върне експорта. Да кажем, че за нашето приложение ни трябват 5 файла, които се импортват, ако не бъндълвахме приложението ние трябваше да направим 5 различни заявки за 5-те файла, но понеже бъндълваме, ние можем да ги комбинираме и да ги заредим на един път. Тези module bundlers, не само бъндълват модулите, но и се използват за транспилация на кода, тоест модерният синтаксис се превежда в по-страрият му еквивалент с цел да поддържа и по-стари барузири. Едни от най-известните bundlers са Webpack, Rollup и Parcel. По принпип не всички бъндлъри се конфигурират, например Parcel, но повечето имат нужда от такава конфигурация.

Следващият проблем, който можем да срещнем е самите различия в платформите. Например в Node.js нямаме document или window обект, в браузъра пък нямаме достъп до файловата система или други ОС компоненти. Един подход за справяне с този проблем е така нареченият runtime branching. Пример:

```js
export function sayHello(name) {
  if (typeof window !== "undefined" && window.document) {
    return render("<h1>Hello, world!</h1>");
  }

  return "Hello, world!";
}
```

В случая, ако сме в браузъра директно искаме да рендерираме на потребителя поздрава, но ако не сме просто искаме да го върнем. Този подход обаче има недостатъци като например bloating-a, който се получава след множество такива if statements, чисто като размер бъндъла ни ще се увеличи, да не говорим за различни security concerns, които бихме създали ако използваме сървър код с различни secrets на клиента.
По подходящият подход е build-time branching-a. За целта използваме tooling предоставен от бъндлърите, който премахва ненужният код по време на билда така че браузър бъндъла да съдържа само браузър код. Пример за такъв tooling e DefinePlugin + TerserPlugin на Webpack, с него можем да установим `BROWSER` променлива, която да използваме така:

```js
if (typeof BROWSER !== "undefined") {
} else {
}
```

По време на бъндлинга ако BROWSER е например true, TerserPlugin-a ще разпознае, че ще се използва кода в if statement-a и ще премахме кода е else клаузата или обратното, това се нарича dead code elimination. В source code-a ни ще имаме тези if-ове, но билда ни ще бъде изчистен.
Друга стратергия би била module replacement, идеята е да имаме два модула с еднакъв интерфейс единият за браузъра, другият за сървъра и да използваме webpack plugin-a NormalModuleReplacementPlugin да заменяме двата модула според нуждите на билда.

Следващата технология, с която се запознаваме е Реакт. Реакт е библиотека за изграждане на реактивен (динамичен) UI и менажиране на стейт. Фундаменталният building block в библиотеката е компонента. Запознаваме се с клас компонентите, които вече почти не се използват, от както бяха въведени hook-овете и function компонентите станаха default-a, през 2019. Запознаваме се и с JSX синтаксиса, но поради факта, че това е вариация на JS, а не е валиден JS, тоест JSX-а трябва да се транспилира, с цел симплификация авторът използва библиотека за tagged template literals. Разглежда се и как се инициализира стейт в конструктора на клас компонента и как се зареждат данни от API чрез lifecycle метода componentDidMount.

След краткото интро в Реакт започваме "универсалното" приложение, първо започваме с обикновено СПА, където използваме hardcoded данни и client side routing, чрез старият react router. Показва ни се стандарна структура на react app, с индекс, апп, components папка и pages папка. Целта следователно е да разширим като добавим SSR, това се постига с допълнителен сървър, който завъртаме с помоща на fastify, което е light-weight web framework. За да подавама статичен контент от fastify server-a, трябва да регистрираме плъгин наречен fastify-static, съответно при регистрацията трябва да подадем конфиг опции и да специфицираме директория, от която ще сервираме статичното съдържание (public) и съответно да отворим catch all get ендпойнт, чрез `*`. Самият SSR ще се случва в гет хандлера, там ще си взимаме урл-а, който се заявява и ще използваме StaticRouter от react router, към когото се подава контекс, който ние създаваме и урл-а, и съответно той рендерира страницата, която ни интересува, след това взимаме съсдържанието stringify-ваме го чрез сецифично utility, изграждаме html-a и го изпращаме. Ако подадем урл, който не съществува StaticRouter, ще зададе на подаденият контекст statusCode = 404.

Следващата стъпка, която предприемаме е да заменим hard coded данните с АПИ, което да ги предоставя. Тук просто завъртаме още един сървър на различен порт и регистрираме няколко ендпойнта, а на фронтенда вместо да импортваме данните използваме заявка, която да се изпълнява при `componentDidMount` & `componentDidUpdate` и ъпдейтва стейта. Това обаче означава, че когато предоставим компонента на клиента той няма да е зареден с данни, а най-вероятно ще е в Loading state & ще трябва да изпълни `componentDidMount` за да получи данните. За да решим този проблем използваме `AsyncPage` class и routes обект, всеки компонент, където е нужен феч на данни, ще extend-ва `AsyncPage` и ще имплементира `preloadData`, който връща данните. Когато сървърът получи рекуест с url той ще използва matchPath utility от react router, за да намери компонента и да изпълни неговият `preloadData` метод, запазва ги в static context и когато стане време да изгради html-a ги инжектира чрез `window.__STATIC_CONTEXT__`, който AsyncPage проверява и задава като стейт.

Общо взето концепциите в тази глава са валидни и интересни за да разберем как някои от инструментите, с които работим днес са се зародили и някои идеи зад тях, но проблемите, които разгледахме вече имат много по-елегантни решения, като Next, Vite, новият React Router, React SC, TanstackQuery и т.н.
