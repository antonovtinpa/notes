---
title: Chapter 13. Messaging and Integration Patterns
sidebar_position: 13
---

В тази глава продължаваме да разглеждаме концeпции, които са тясно свързани със скалируемост. В миналта глава споменахме Message Queues, като способ за комуникация на отделни services, когато прилагаме скалиране по Y Axis. В тази галва разгръщаме общата идея за Messaging, разглеждаме фунадамента и различни pattern-и, които можем да използваме в нашата интеграция.

Нека започнем с няколко фундаментални идеи. Message системите общо казано могат да се разделят по няколко критерии. Първият критерии е посоката на комуникация, тя може да е еднопосочна или още позната като fire-and-forget, като например определен producer създава task-ове и consumers, които ги поемат и изпълняват, тя може да е също request/reply или двупосочна, която е малко по-сложна за имплементиране и ще разгледаме по-късно. Вторият критерии е целта на съобщението, като тук имаме три вида цели command, подава се точно оперделена команда от producer и се изпълнява от consumer, event, подава се определено нещо, което се е случило и consumer-ите сами решават как да реагират & document, това е съобщение, което предава определени данни като payload. Имаме и разделение на база timing, имаме синхронни и асинхронни message systems, като в Node.js света най-вече разчитаме на асинхронност, с цел да постигнем самостоятелност, бързина и издръжливост. Последният критерии, който имаме е на база доставяне, то може да е peer-to-peer или с други думи директно от един node към друг или Broker-Based, в който имаме брокер, който служи за посредник и в много случаи ни помага с други неща като routing, persistence и други, които ще разгледаме по-късно.

Един от основните pattern-и, когато става въпрос за messaging е Pub/Sub (Publisher/Subscriber). Това едно от много вариации на Observer pattern-a. Идеята е че имам publishers, които подават съобщения към даден topic или канал, а от другата страна имаме subscribers, които са абониране за споменатия topic/channel, получават копия на публикуваните събщенията и ги консумират. Този подход ни дава гъвкавост, поради самостоятелността на елементите. Самият Pub/Sub на практика има много и различни имплементации, общо казано голямата разлика е дали имплементацияте е peer-to-peer или broker-based. При peer-to-peer една имплементация може да е по-проста и съответно по-лимитирана, например да се отвори една web socket връзка, използвайки библиотеки като `socket.io`, където всеки вързан клиент да може да публикува съобщения към определен канал и съответно на база тези пуликации да получава новите съобщения. Друг по-софистициран вариант би бил използването на `ZeroMQ`, което като технология вече приспада към message queues, за разлика `socket.io`, което е high level абстракция на протокол за комуникация. `ZeroMQ` всъщност се използва за играждане на много други видове архитектури, но ни позволява и да имплементираме и Pub/Sub, чрез специални сокети PUB & SUB, като publisher-a се връзва към определен адрес за да публикува и всички абонати, които съще се свържат към къщия адрес ще получават тези публикации. Съответно лимитациите на тези имплементации са, че съобщенията не се пазят и абонати, които не са били на линия по време на публикацията никога няма да я получат. За да решим този проблем можем да използваме Broker-based имплементация, чрез технологии като RabbitMQ. RabbitMQ имплементира така нареченият Advanced Message Queueing Protocol (AMQP), който разделя messaging system-aта на няколко части, publisher, broker, в който има exchange, bindings & queues и consumers. В нашия случай брокерът е това, което би могло да реши проблема. Publisher-ът изпраща съобщения към exchange, който ги route-ва към една или повече опашки. Ако опашките са конфигурирани като durable, а съобщенията - като persistent, те ще се запазят дори при рестарт на системата. Така гарантираме, че нито едно съобщение няма да бъде изгубено, дори ако абонатите не са били свързани в момента на публикуване. По принцип може би факта, че трябва да конфигурираме това държание подсказва, че това не е точно предназначението на message queues като RabbitMQ. По default в повечето случаи използваме message queues за fire-and-forget тип системи, в нашият случай чрез таки конфигурация по-скоро мимикираме event stream-овете или още познати като event log-ове. Такива технологии са Redis Streams & Kafka при тях системата е малко по-сложна. Например при Kafka пак имаме producers & consumers, но съобщенията са разделени на partitions, всеки от който има topic, един topic може да се консумира от множество consumers, като консумацията става не на база кой е следващото съобщение в опашката, както е при message queue-тата, а на база кое беше последното съобщение, което аз съм прочел, понеже съобщенията са персистентни в лог-а. С други думи консумирането става на база персонален офсет на консуматора. Съответно ако искаме едно съобщение да се приема само от един косуматор можем да изградим така наречените consumer groups. Както message queues, така и event/message streams/logs са broker-based messaging systems, но приложенията са различни и съответно трябва да съобразим нашите нужди с целта на технологията. Като обощение можем да кажем следното: Peer-to-peer системите са по-low level, по-сложни са за интеграция за големи приложения, в повечето случаи сами трябва да превидим механизми за загубени съобщения, за сметка на това са много по-бързи и по-издръжливи (не като цяло, а в точно определен аспект) поради факта, че всяка връзка е директна и самостоятелна. Broker-based системите от своя страна са по-бавни, правят ни vendor зависими, но за сметка на това са много по-гъвкави, по-издружливи, поради множеството механизми, които ни предлагат, много по-лесно скалируеми.

Една от най-често срещаните нужди, които message системите задоволяват е прехвърлянето на задачи, тоест комуникацията между отделни компонент с цел изпълнение на една сложна задача или по друг начин казано изграждането на work pipelines. Пример за такъв pipeline и ползите от използването на message queues би бил транскодирането на едно видео. Определено видео трябва да бъде обработено така че да поддържа различни резолюции (240, 360, 420, 680, 720, 1080), за тази цел, ние можем да имаме следнят flow. Клиент праща видео - чрез message queue URL-a на всяко видео се изпраща на blocking service, който разделя видеото на чънкове, които са по-малки по размер. След това за всеки чънк се изпраща отделно съобщение, като към това съобщение имаме множество консуматори или множество consumer groups, като всеки консуматор ще е service, който има за цел да encode-не чънк-а от един bitrate (оригиналния) към друг (240, 360, 420...), след това всеки от тези services има за задача да изпрати съобщение, че чънка е готов на друг service, който ще ги съедини и качи в storage. Това е така нареченият fan out/fan in модел, можем да забележим, че една задача се разделя на други по-малки, които могат да се изпълнят паралелно и след това разултати се съединяват. Това е много ефективна техника и е широкоизползвана. Освен очевидното препращане на съобщенията messaging system-ите правят тази имплементация балансирана поради load balancing механизмите, които прилагат и също така я правят издръжлива и fault resistant, поради acknowledgment механизма, който прилагат. По default повечето messaging systems прилагат At-Least-Once Delivery, което означава, че едно съобщение ще се достави поне веднъж, но ако консуматора дропне то тогава то може да бъде retry-нато и съответно неговият ефект да се дубликира. По принцип acknowledgment-а е задължение на консуматора като различните системи предоставят възможност за това по различен начин. Има и системи, които прилагат At-Most-Once Delivery и Exactly-Once Delivery, като AMOD би се приложило при системи, които са Loss tolerance, а EOD е идеалът за една messaging system-a, но е много трудно постижим.

Последният pattern, който ще разгледаме е двупосочният messaging или request/reply pattern-a. В повечето случаи ние имаме някакъв Pipeline или еднопосочна комуникация, но в случаите, в които искаме изградим ефективен flow, в който да получим отговор на определено съобщение трябва да приложим две основно идеи. Първата е Correlation Identifier, с прости думи това е ID за определена задача. Да кажем един service подава задача за някакво изчисление чрез определен topic на втори service и продължава работата си, веднъж щом вторият service e готов той би пратил съобщение към различен topic за да обяви отговорът от изчислението, с други думи имаме два topic-a - `calculation & result`. При `"calculation"` `service A` e producer, a `service B` consumer, при topic `"result"` обратното. Идеята на Correlation Identifier-а е да се установи корелацията между заявката за калкулиране и резултата. Другата идея е Return Address-а общо взето return address-a е `result` topic-a, въпросът е че не винаги искаме той е статичен и в повечето случаи искаме producer-a да опердели къде ще се прати резултата. Тези две концепции са фундаментални и се използват от повечето messaging systems под различни форми.
